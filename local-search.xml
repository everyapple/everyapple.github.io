<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>性能指标优化</title>
    <link href="/2023/12/09/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/09/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="性能监测">性能监测</h2><p>前端性能监控分为合成监控(lighthouse类)和真实用户监控(获取性能指标上传服务器，提取清洗加工)。</p><p>合成监控数据量小，无法完全还原真实场景，单次运行数据不够稳定。</p><p>页面加载不同阶段可监控的指标如下图</p><p><img src="https://static.geekbang.org/infoq/5c6bce24ba464.png" alt="性能指标流程图"></p><p>我们主要把控的指标为 FCP、 LCP 和 CLS，其他性能指标如 FP、FCP、LCP、TTI、FID也都会讲解如何监控</p><h3 id="FCP">FCP</h3><p>衡量首屏时间。第一个内容区域绘制时间</p><p>超能力 FCP: 0.84s 91%</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> po = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> l.<span class="hljs-title function_">getEntries</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;first-contentful-paint&#x27;</span>) &#123;<br>      po.<span class="hljs-title function_">disconnect</span>()<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fcp 相关&#x27;</span>, entry)<br>  &#125;<br>&#125;)<br><br>po.<span class="hljs-title function_">observe</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><h3 id="LCP">LCP</h3><p>视口内出现最大图片或文本块的呈现时间。</p><p>超能力项目的LCP：0.44s 89%</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LCP candidate:&#x27;</span>, entry.<span class="hljs-property">startTime</span>, entry);<br>  &#125;<br>&#125;).<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="CLS">CLS</h3><p>网页的整个生命周期内发生的布局最大偏移量</p><p>通过减少CLS，可以减少用户因为页面突然移位造成的误触概率。</p><p>在线换座 CLS: 0.05 P90</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">entryType</span> === <span class="hljs-string">&#x27;layout-shift&#x27;</span>) &#123;<br>      <span class="hljs-comment">// CLS</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLS</span> = entry.<span class="hljs-property">value</span> ? entry.<span class="hljs-property">value</span> * <span class="hljs-number">1000</span> : <span class="hljs-number">0</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">CLSParams</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, extraInfo, &#123; <span class="hljs-variable constant_">CLS</span> &#125;)<br>      <span class="hljs-title function_">sendPerformance</span>(<span class="hljs-title class_">CLSParams</span>)<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;layout-shift&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="FP">FP</h3><p>页面第一个像素点出现的时间，也用来衡量白屏时间。</p><p>计算规则与FCP一致, <code>entry.name === 'first-paint'</code></p><h3 id="TTI">TTI</h3><p>计算标准是 FCP 之后，直到页面内没有<strong>任何超过50ms的任务</strong>，为TTI。</p><h4 id="长任务">长任务</h4><p>任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。比如以下常规场景：</p><ul><li>长耗时的事件回调</li><li>代价高昂的回流和其他重绘</li><li>浏览器在超过 50 毫秒的事件循环的相邻循环之间所做的工作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) &#123;<br>  <span class="hljs-keyword">var</span> perfEntries = list.<span class="hljs-title function_">getEntries</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perfEntries.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 包括  multiple-contexts self same-origin 等 </span><br>    <span class="hljs-comment">// 多处来源 页面自身 </span><br>  &#125;<br>&#125;);<br>observer.<span class="hljs-title function_">observe</span>(&#123; <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&quot;longtask&quot;</span>] &#125;);<br></code></pre></td></tr></table></figure><p>长任务结束后计算TTI</p><h3 id="FID">FID</h3><p>第一次输入框交互反馈时间，也可记为交互返回时间，只有触发交互后才可统计</p><h2 id="造成以上几个指标出现问题的原因">造成以上几个指标出现问题的原因</h2><ul><li>首页加载很多未使用的css，会阻塞html渲染</li><li>css包含大量重复的font-face</li><li>字体文件使用ttf格式，未使用适用现在woff2格式，且字体文件较大</li><li>自定义字体未设置 font-display:swap 导致字体下载未完成时显示空白</li><li>图片资源过大，未使用webp等针对web优化的格式</li></ul><h2 id="主要优化过程">主要优化过程</h2><p><strong>主要分为三个方向，拆包、压缩和预加载</strong></p><ul><li><p>拆包</p><p>web应用由多个文件(脚本、样式、图像等)组成的bundles，拆包可以减少单个页面所需加载的资源量</p></li><li><p>压缩</p><p>较少传输过程的数据量、提高数据传输速度</p></li><li><p>预加载</p><p>页面加载时提前请求并加载将来可能需要的资源</p></li></ul><h3 id="通过-webpack-bundle-analyze-分析包结构">通过 webpack bundle analyze 分析包结构</h3><p>将引入的其他插件模块 例如 lottie-web，在页面需要时异步引入</p><h3 id="使用-Performance-面板">使用 Performance 面板</h3><p>分页页面性能、加载时间、js执行时间、渲染时间、函数调用堆栈</p><p>查找出的问题</p><ul><li>script 未添加defer，导致串行加载和执行，影响FCP指标</li><li>js 调用栈深 影响性能</li></ul><h3 id="优化方式">优化方式</h3><h4 id="拆包">拆包</h4><p>页面异步加载</p><h4 id="构建工具优化">构建工具优化</h4><h4 id="资源优化">资源优化</h4><ul><li><p>本地引用的图片需要压缩后引用，tinypng</p></li><li><p>使用webp格式cdn</p><ul><li>webp格式降级策略</li></ul><p><strong>客户端</strong></p><p>加载一个1 * 1的webp图片，通过是否能获取到宽高判断浏览器是否支持webp，之后全局注入判断</p><p><strong>服务端</strong></p><p>根据请求的header信息判断是否支持webp，Accept: image/webp,</p></li><li><p>业务中实现图片懒加载</p></li><li><p>设置 font-display: swap, 在字体加载完成之前，文本元素将使用系统字体或默认字体，避免 FOIT (不可见文本闪烁) FOUT（无样式文本的闪烁）</p></li><li><p>字体离线化 (service-worker 暂未使用)</p></li><li><p>DNS 预加载，对跨源域上的资源有效，提前解析域名的dns，提高加载速度(最好是最关键的资源连接)</p></li><li><p>代码体积压缩 uglifyjs cssnanno 等</p></li><li><p>purifycss 移除未使用的css代码</p></li><li><p>代码异步加载</p></li></ul><h4 id="代码性能">代码性能</h4><ul><li>组件分级策略 (容器组件、区域组件、小型纯展示组件)</li><li>合理利用 memo、useMemo、useCallback、 useContext</li><li>尽量使用css动画延迟执行，而非js定时器</li><li>使用第三方包注意代码体积 (moment vs day) dayjs文件更小2.2k &lt; 60.8k</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于http的一一二二</title>
    <link href="/2023/11/15/http%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/15/http%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存机制">缓存机制</h2><p>在web中，http请求一般都是浏览器发起的，所以我们这里所说的http的缓存策略，其实也就是浏览器端的缓存策略，因为http本身只是一种协议，真正实现缓存还是要靠浏览器（其实就是浏览器指定存储在硬盘下。）<br>首先，我们要知道一点：http的缓存策略，是由客户端和服务器端共同去控制的，客户端可以通过在请求头里添加Cache-Control等字段来决定是否走缓存，服务器端也可以在响应头中添加Cache-Control等字段来告诉客户端是否可以缓存数据。<br>不管是客户端还是服务器端都是通过http头中的不同字段来控制的。<br><img src="https://s2.loli.net/2023/11/15/M1xqdRwAlSy4EoD.png" alt="缓存流程"></p><h3 id="强缓存">强缓存</h3><h4 id="cache-control-http1-1提出">cache-control (http1.1提出)</h4><p><img src="https://s2.loli.net/2023/11/15/IAUNJOQkyCH8ahr.png" alt="cache-control"></p><h4 id="Expires-（优先级低）">Expires （优先级低）</h4><p>Expires表示服务器端告诉客户端当前资源的失效时间，截止到哪个时间点，是一个绝对时间，即过了这个时间点请求的话，就说明缓存已经失效啦，但是由于服务器端时间和客户端时间可能存在偏差，这也就是导致了最后缓存的时间误差，另一方面，该字段是http1.0提出来的，现在我们基本都是用cache-control:max-age:30来替代。<br><strong>Expires 是 HTTP/1.0 的首部，Cache-Control 是 HTTP/1.1 的首部，Expires 首部和 Cache-Control:max-age 首部所做的事情本质上是一样的，但由于 Cache-Control 首部使用的是相对时间而不是绝对日期，所以更倾向于使用比较新的Cache-Control首部。绝对日期依赖于计算机时钟的正确设置。</strong></p><div class="note note-primary">            <p>强制再验证：Pragma: no-cache<br>与 Cache-Control: no-cache 效果一致，当响应头中包含该指令时，当客户端再次发起请求时，会强制要求使用缓存之前将请求提交到源服务器进行验证。</p>          </div><div class="note note-primary">            <p>cache-control优先级大于expires，只看cache-control<br>因为现在都是http1.1，所以关于强缓存真正起到作用的就是 cache-control 字段。</p>          </div><div class="note note-success">            <p>唠一下 etag的生成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">ETAG</span>: &lt;weak&gt; opaque-tag <br></code></pre></td></tr></table></figure><p>weak表示强校验和弱校验。初始带有W/表示弱校验。<br>区别在于强校验是逐字节的对比，而弱校验是语义相等。<br>HTTP/1.1协议虽然提出了 ETag，但并没有规定ETag的内容是什么或者说要怎么实现，唯一规定的是ETag的内容必须放在&quot;&quot;内。<br>虽然说他没有规定，但是一般而言：<br>ETag生成结论</p><ol><li>对于静态文件（如css、js、图片等），ETag的生成策略是：文件大小的16进制+修改时间</li><li>对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值</li></ol>          </div><div class="note note-warning">            <p>Q:那么 etag变化了，文件一定修改了吗？<br>A:不一定，根据etag的生成算法决定，如果是根据修改时间判断的话，比如编辑了文件但没有改变文件内容的话，则etag改变而文件没有修改。</p>          </div><h3 id="协商缓存（服务端再验证）">协商缓存（服务端再验证）</h3><h4 id="Etag-If-none-match">Etag/If-none-match</h4><p>If-None-Match 的值为服务端上一次返回的 ETag 的值。在 ETag 的值前面添加 W/ 前缀表示可以采用相对宽松的算法。<br>Etag是上一次加载资源时，服务器生成的唯一标识，如果文件修改，则etag值会变化</p><h4 id="Last-modified-If-modified-since">Last-modified/If-modified-since</h4><p>If-Modified-Since 的值为服务端上一次返回的 last-modified 的值。如果在此期间内容被修改了，最后的修改日期就会有所不同，源服务器就会回送新的文档。否则，服务器会认为缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个 304 NotModified 响应。<br>Last-Modified是该资源文件最后一次更改时间,服务器会在response header里返回</p><div class="note note-primary">            <p>如果两个字段都收到，则要同时满足这两个条件才可以用缓存。<br>一般都是同时启用。<br>因为分布式系统尽量关掉ETag，因为每台机器生成的ETag不一样。这个时候就需要last-modified</p>          </div><div class="note note-success">            <p>为什么etag的优先级更高呢<br>在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度<br>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br><strong>在优先级上，服务器校验优先考虑Etag。</strong><br>所以，两者互补。</p>          </div><h2 id="用户行为对浏览器缓存的控制">用户行为对浏览器缓存的控制</h2><h4 id="地址栏访问">地址栏访问</h4><p>链接跳转或者是书签页打开，是正常的用户行为，会走浏览器缓存</p><h4 id="F5刷新">F5刷新</h4><p>浏览器会将请求头设置为max-age:0，跳过强制缓存，但还是会走协商缓存，浏览器会对本地文件过期，但会带上其他两个头。根据if-none-match、if-modified-since判断。也就是说会检查新鲜度。</p><h4 id="ctrl-F5强制刷新">ctrl+F5强制刷新</h4><p>跳过强缓存和协商缓存，直接从服务器拉最新的资源。浏览器不仅会对本地文件过期，也不会带上其他两个头。相当于之前从来没有请求过，也就是200</p><h3 id="如何不走缓存">如何不走缓存</h3><h4 id="cache-control">cache-control</h4><ul><li>no-cache：无论资源是否过期，都去协商缓存</li><li>no-store:禁止一切缓存</li><li>must-revalidate</li></ul><h4 id="expires">expires</h4><p>设置在当前时间之前</p><h4 id="前端如何设置呢">前端如何设置呢</h4><ul><li>引入js，css文件url加上Math.random()值</li><li>页面上设置不让缓存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;meta http-equiv=<span class="hljs-string">&quot;pragma&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span>&gt; <br>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, must-revalidate&quot;&gt; <br>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 00:00:00 GMT&quot;&gt;<br></code></pre></td></tr></table></figure><h3 id="其他">其他</h3><p>强缓存会有两种形式存在， memory cache  和  disk cache</p><ul><li>memory cache 资源存在内存中，如js，图片，字体等</li><li>disk cache 非js文件，如css。</li></ul><h2 id="http1-1和http2的改变">http1.1和http2的改变</h2><h3 id="http1-1的区别">http1.1的区别</h3><ol><li>缓存处理：引入了cache-control、etag等缓存</li><li>范围请求：在请求头添加了range头域，允许只请求资源的某个部分，返回206，支持断点传续</li><li>新增24个错误码：206 409（请求资源与当前资源冲突） 410（服务器上的资源被永久删除）</li><li>Host头：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此， 请求消息中的URL并没有传递主机名（hostname） 。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request） 。有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</li><li>持久连接：connection：keep-alive就是tcp默认不关闭，可以被多个请求复用</li><li>管道机制： 在一个tcp连接中，客户端可以同时发起多个请求。</li></ol><h4 id="http1-1">http1.1</h4><p><strong>优点</strong></p><ul><li>1.0 每个 tcp 只能发送一个请求，1.1 引入长连接，tcp 链接默认不关闭，可以被多个复用</li><li>管道化，同个 tcp 连接里，客户端可以同时发送多个 http 请求，不用等待一个个响应 (6-8 限制)</li><li>支持断点续传</li></ul><p><strong>缺点</strong></p><ul><li><p>队头阻塞</p><p>由于 http 遵守“请求-响应”的模式，页面中发起多个请求，<strong>同一个 TCP 链接中</strong>，每个请求必须等到前一个请求相应之后才能发送。如果一个 TCP 通道中某个 http 请求没有及时返回，后面的相应会被阻塞</p></li><li><p>不安全性</p><p>无法验证通信双方的身份，也不能判断报文是否被窜改</p></li><li><p>明文传输</p><p>数据肉眼可见，能够方便地研究分析，但也容易被窃听</p></li></ul><h3 id="http2的改动">http2的改动</h3><ol><li><p>二进制分帧：HTTP/1.1的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制；HTTP/2 头信息和数据体都是二进制，统称为<span class="label label-primary">“帧”</span>：头信息帧和数据帧；</p></li><li><p>多路复用： 也就是双工通信。可以发起多重的请求-响应消息。就是说在一个连接里，客户端和服务端都可以发起多个请求和响应，不用按顺序。也就是解决了队头堵塞的这个问题。HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p></li><li><p>数据流：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。HTTP/1.1取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p></li></ol><p><strong>请求优先级</strong></p><ol start="4"><li><p>首部压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法）。；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></li><li><p>serve push 服务端推送： 允许服务端主动向客户端发起请求。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p></li></ol><h4 id="http2-0性能瓶颈">http2.0性能瓶颈</h4><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个Tcp的packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对ht2.0下的TCP配置优化至关重要。</p><h3 id="https">https</h3><p>ssl/tls：公钥加密法<br>客户端向服务端索要并验证公钥，然后用公钥加密传输，生成对话秘钥（非对称加密），对方采用对话秘钥进行通信（对称加密）</p><h2 id="PWA-Service-worker">PWA &amp; Service worker</h2><p>Progressive Web Apps  一个渐进式的web应用，主要是为了提升用户的体验，不是某个单一的技术，其核心技术包括 Web App Manifest，Service Worker，Web Push 等。</p><h4 id="service-worker-和-workder的区别">service worker 和 workder的区别</h4><ol><li>worker 是一种web worker技术，他允许独立于主线程运行的一个脚本，可以放一些<span class="label label-primary">计算密集型任务</span>在worker里，防止阻塞主线程渲染。</li><li>service worker 是一种全新的web worker技术，他可以用来管理网络请求，缓存数据，包括离线优化等等。还可以发送推送通知等等。是浏览器在后台独立于网页运行的脚本.</li></ol><div class="note note-primary">            <p>service worker拥有更高的权限，可以管理网络，缓存，通知等等，他们都是通过postmessage通信的。</p>          </div><h2 id="get和post的区别">get和post的区别</h2><p><a href="https://github.com/febobo/web-interview/issues/145">https://github.com/febobo/web-interview/issues/145</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论经常性问题的深究和研究</title>
    <link href="/2023/11/15/%E8%AE%BA%E7%BB%8F%E5%B8%B8%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%B7%B1%E7%A9%B6%E5%92%8C%E7%A0%94%E7%A9%B6/"/>
    <url>/2023/11/15/%E8%AE%BA%E7%BB%8F%E5%B8%B8%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%B7%B1%E7%A9%B6%E5%92%8C%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>对于一些经典问题的收集和汇总，主要纠结于一些常见问题但不深入理解的地方。</p><h2 id="js判断数据的类型">js判断数据的类型</h2><p>常见的有三种</p><ol><li>typeof</li><li>instanceof</li><li>Object.prototype.toString.call()</li></ol><h4 id="typeOf">typeOf</h4><p>一般是用来判断基本类型的，比如String，Number，undefined，Boolean，bigInt，Symbol，也可以判断object，function。<br><strong>对于null返回的是object</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">// function</span><br><span class="hljs-keyword">typeof</span> object <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Null</span> <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">//object</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>为什么typeof null 为object<br>因为历史遗留问题，在js中，不同的对象都是用二进制存储的，如果二进制前三位都是0，会判断为object，而null都是0</p>          </div><h4 id="instanceof">instanceof</h4><p>一般用来判断引用类型，判断基本数据无效<br>主要作用就是判断一个实例是否是其父类型或者祖先类型，也就是查找目标对象的原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="Object-prototype-toString-call">Object.prototype.toString.call</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;null&quot;</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/15/f3j2NDcUBpwyoxL.png" alt="懒得打字了"></p><h4 id="typeof-和-instanceof-的区别">typeof 和 instanceof 的区别</h4><ol><li>typeof 返回一个类型， instanceof返回一个boolean值</li><li>typeof 判断基本类型， instanceof判断引用类型</li><li>typeof 对所有引用类型除了function之外都是object</li></ol><h2 id="浏览器字体默认最小12px，如何变成10px">浏览器字体默认最小12px，如何变成10px</h2><ol><li>zoom</li><li>scale</li><li>css -webkit-text-size-adjust<br>transform 属性 scale zoom<br>主要原因是浏览器做了最小的限制</li></ol><h4 id="zoom">zoom</h4><p>zoom是变焦，可以用百分比，normal，数值。可以改变页面上元素的尺寸，会引起页面的重排。缩放相对于左上角。</p><h4 id="scale">scale</h4><p>对元素的缩放，transfrorm:scale()<br>不改变页面布局，不会引起重排，不可以是百分比和normal，但可以是负数。<br>同时也可以决定某个维度，scalex，scaley<br>若为负数，就是对那个元素的翻转。<br>缩放相对于居中。</p><h4 id="css属性-webkit-text-size-adjust：none">css属性  -webkit-text-size-adjust：none</h4><p>设定文字大小是否根据设备浏览器大小调整</p><h2 id="内存泄漏如何定位">内存泄漏如何定位</h2><p>内存泄漏定位 performance ——+————memory 堆快照</p><h2 id="intersection-oberserve">intersection oberserve</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, option);<br></code></pre></td></tr></table></figure><p><a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html">https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webapck</title>
    <link href="/2023/11/08/webapck/"/>
    <url>/2023/11/08/webapck/</url>
    
    <content type="html"><![CDATA[<p>webpack是一个打包工具，他会把js，css，图片，html文件，分析整个文件的目录结构，确认文件之间的依赖，通过编译，转换，生成js格式的bundle文件。他把所有的文件当成模块。</p><h2 id="webpack打包过程">webpack打包过程</h2><ol><li>根据entry入口文件，调用所有配置的loader对象进行编译<br>因为webpack只能处理js，css等其他格式需要loader辅助进行编成js后进行打包</li><li>利用babel将js转为ast，在用babel-traverse对ast进行遍历</li><li>遍历的目的是为了找到import引用节点，也就是依赖关系</li><li>根据引用节点，引入模块，生成唯一标识的id，并将解析过的模块缓存起来。如果其他地方也引入了模块，则不需要重新解析，生成一个依赖图谱。</li><li>递归遍历所有的模块，根据依赖图谱，生成一个个chunk（包含多个模块）</li><li>将生成的文件输出到output中。</li></ol><h2 id="Tree-shaking-原理">Tree-shaking 原理</h2><p>基于 ESM 模块规范，在运行过程中静态分析模块之间的导入导出，确认ESM模块中哪些导出值未被其他模块使用，并将其删除。</p><ul><li>收集模块导出变量并记录到模块依赖图中</li><li>遍历模块图，标记模块导出变量有没有被使用</li><li>生成产物时，若变量未被引用则删除其对应的导出语句</li></ul><p><a href="https://juejin.cn/post/7002410645316436004">更多细节点击这里</a></p><h2 id="webpack-压缩代码的原理">webpack 压缩代码的原理</h2><p><a href="https://q.shanyue.tech/fe/js/138">点击链接查看</a></p><h2 id="热更新的原理">热更新的原理</h2><blockquote><p>先介绍功能点</p></blockquote><p>webpack-dev-server 主要包含了三个部分：</p><ol><li>webpack: 负责编译代码</li><li>webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。</li><li>express：负责搭建请求路由服务。</li></ol><blockquote><p>介绍工作流程</p></blockquote><p>对代码进行修改的时候，webpack会对代码进行重新打包;通过 webpack 创建的 complier 实例， 可以往<code>compiler.hooks.done</code>(webpack 编辑完成的钩子)注册事件;当监听到一次 webpack 编译结束，会通过 websocket 向客户端发送 hash 和ok 事件;客户端接收服务端的推送信息后，对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块;获取到新的JS模块后，会更新 modules tree并替换掉现有的模块;最后调用 module.hot.accept() 完成热更新.</p><p>&lt;%note primary%&gt;<br>热更新在webpack里主要是根据websocket，建立双方的通信。当代码发生变化时，通知浏览器请求新的模块，替换原来的。<br>&lt;% endnote%&gt;</p><h4 id="webpack">webpack</h4><p>HMR的核心就是客户端将新的文件从服务端拉取，也就是chunk diff<br>wds（webpack-dev-server）和服务端之间建立一个websockt连接，进行通信。<br>本地资源发生变化后，wds就向服务端发起更新，带上hash，让浏览器进行对比。<br>客户端对比出差异后，就会向wds发送ajax请求获取更新的内容。</p><p>当一个文件发生变化，webpack监听到这个变化对文件重新编译打包，生成hash值，</p><p><strong>是全量更新，即便更改一个文件，也会重新编译整个文件。</strong></p><h4 id="vite">vite</h4><p>以原生esm形式服务源码，只要在浏览器请求源码的时候获取源码进行转换再返回转换的源码，所以比webpack热更新更迅速。<br>&lt;% note primary %&gt; vite是增量更新，只更新修改的**<br>&lt;% endnote%&gt;</p><ol><li>利用原生的esmodule模块，开发时可以跳过打包过程，提升编译效率</li><li>当通过import加载资源，浏览器发起http请求时，vite会拦截http请求，返回对应的文件。</li></ol><h3 id="webpack-和-vite-热更新的区别">webpack 和 vite 热更新的区别</h3><ol><li>wepack的热更新，是在某个依赖更改的情况下，会将该依赖所处的整个module都重新更新，也就是说如果依赖越来越多，编译的速度会慢。</li><li>vite：如果某个文件发生变化，只会更新这个文件。其他文件都无需更新。</li></ol><p>webpack是一个静态资源打包文件，将项目文件组合编译在一起。</p><p>是一个打包工具。</p><p>他的本身功能比较少，只能处理js文件。</p><h4 id="五大核心概念">五大核心概念</h4><ul><li>entry  入口</li><li>output 编译好的文件放置位置</li><li>loader 除了js json等资源的 其他输入</li><li>plugin 扩展功能</li><li>mode 开发模式 生产模式  等</li></ul><h4 id="开发模式作用">开发模式作用</h4><p>1.编译代码</p><p>2.代码质量检查，代码规范</p><h4 id="处理样式文件">处理样式文件</h4><p>webpack不能识别样式资源，借助loader实现</p><p>如果不用css-loader style-loader等loader处理器 会编译失败 需要一个loader解析</p><hr><p>处理图片资源</p><p>wepback4: file-loader url-loader</p><p>将10kb以下的图片转为base64格式 可以减少请求数量 但是相应体积变大  转成base64的图片 已经压入了js中</p><p>更改配置 需要删除dist内容  自动清空上次打包结果：output→clean:true</p><h4 id="处理字体资源">处理字体资源</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  test：/\.(ttf|woff2?)$/<br>  <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;asset/resource&quot;</span>,<br>  <span class="hljs-attr">generator</span>:&#123;<br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&quot;static/media/[hash:8][ext][query]</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>asset/resource:  相当于file-loader， 将文件转成能识别的资源</p><p>asset：相当于url-loader， 转成识别资源，同时小于某个大小的资源会处理成data-url</p><h4 id="处理js资源-plugin">处理js资源 plugin</h4><p>代码格式 ： eslint</p><p>js兼容：babel</p><hr><p>先完成eslint检测 再用babel</p><h4 id="Eslint">Eslint</h4><ul><li><p>parseOptions  解析选项</p><p>sourceType es模块化</p><p>ecmaFeatures :{jsx:true} 其他特性</p><p>ecmaVersion: es版本</p></li><li><p>rules 具体规则</p><p>0 —off</p><p>1—warn</p><p>2—error</p></li><li><p>extend  继承现有规则</p></li></ul><p>在webpack5中eslint作为一个插件  需要用new调用</p><h4 id="Babel">Babel</h4><p>将es6语法编写的代码向后兼容，其他浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">preset</span>:[]<br>&#125;<br></code></pre></td></tr></table></figure><p>babel-loader</p><h4 id="处理html资源">处理html资源</h4><p>html-webpack-plugin</p><p>自动引入打包生产的js文件 内容和源文件一致</p><h4 id="自动化-开发服务器">自动化&amp; 开发服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">devServer</span>:&#123;<br>    <span class="hljs-attr">host</span>:<br>    <span class="hljs-attr">port</span>:<br>    <span class="hljs-attr">open</span>:<span class="hljs-comment">// 自动打开浏览器</span><br>  &#125;<br>&#125; <span class="hljs-comment">// 平级 entry</span><br></code></pre></td></tr></table></figure><p>指令→npx webpack serve</p><h4 id="css提取">css提取</h4><p>mini-css-extract-plugin</p><p>css打包到js文件中，会创建一个style标签，造成闪屏</p><p>所以提取单独的css文件， 通过link标签加载性能</p><ul><li>loader：style-loader去掉 改为 mini的loader</li><li>plugin：加载 插件</li></ul><h4 id="css压缩">css压缩</h4><p>css-minimizer-webpack-plugin</p><h2 id="高级webpack优化">高级webpack优化</h2><h4 id="提升开发体验-—-sourceMap：源代码映射">提升开发体验  —-sourceMap：源代码映射</h4><h4 id="提升打包速度">提升打包速度</h4><p>1.HotModuleReplacement HDR 热模块替换</p><p>webpack默认将所有模块都进行打包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">devServer</span>:&#123;<br>  <span class="hljs-attr">hot</span>:<span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>避免整个页面刷新</p><p>2.OneOf 只匹配上一个loader</p><p>3.exclude include</p><p>4.cache 缓存</p><p>5.thead</p><p>多进程打包</p><p>每个进程启动都有时间 所以要在特别耗时的操作中进行 启动进程的核数就是cpu的核数</p><h4 id="减少代码体积">减少代码体积</h4><p>1.Tree-shaking 移除js中没用上的代码 依赖es module</p><p>2.babel  plugin-transform-runtime 禁用babel自动对每个文件注入runtime</p><p>3.Image minimizer</p><h4 id="优化代码运行性能">优化代码运行性能</h4><p>1.Code split 代码分割 生成多个js文件 按需加载</p><ul><li><p>多入口</p></li><li><p>提取公共代码</p></li><li><p>按需加载</p></li><li><p>单入口  pulgin:[‘import’]</p></li><li><p>给动态导入取名字</p></li></ul><p>2.preload prefetch</p><p>按需加载带来的卡顿  在浏览器空闲时间加载后续使用资源</p><p>preload： 立即加载 优先级高</p><p>prefetch： 空闲加载 优先级低</p><p>共同点：加载不执行 缓存</p><p>不同： preload只加载当前页面</p><p>插件 preload-webpack-plugin</p><p>3.Network Cache 更新文件名 读取缓存</p><p>4.Core-js</p><p>async promise babel无法解决</p><p>所以需要core-js 解决兼容性问题 做es6以上的api的polyfill</p><p>5.PWA 提供离线体验 通过service workers</p><h1>总结</h1><ul><li><p>提升开发体验</p><p>SourceMap  准确的错误提示</p></li><li><p>提升打包速度</p><p>hdr 热更新</p><p>oneof</p><p>include exclude</p><p>cache</p><p>thead</p></li><li><p>减少代码体积</p><p>treeshaking</p><p>禁用babel自动导入runtime</p><p>本地图片压缩</p></li><li><p>优化代码</p><p>code split 代码分割 多入口 按需加载</p><p>core-js 提升兼容性问题</p><p>preload prefetch 提前加载</p><p>network cache 缓存</p><p>pwa 离线访问</p></li></ul><h1>loader :帮助webpack识别不能识别的模块</h1><p>执行顺序： pre， normal， inline， post 从右到左， 从下到上</p><h3 id="开发一个loader">开发一个loader</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>= <span class="hljs-keyword">function</span> <span class="hljs-title function_">loader1</span>(<span class="hljs-params">content</span>)&#123;<br>  <span class="hljs-keyword">return</span> content<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="loader接受的参数">loader接受的参数</h4><p>需要返回一个webpack要输出的东西，loader本质是一个函数</p><p>content：源文件内容</p><p>map：sourceMap</p><p>meta：数据</p><p>默认normal-loader</p><h4 id="loader的分类">loader的分类</h4><p>同步 异步 raw pitch</p><p>raw：buffer数据流 处理图片文件</p><p>pitch:提取终止</p><p>pitch顺序:从左到右 中断返回上一个</p><h4 id="手写babel-loader">手写babel-loader</h4><h2 id="plugin：插件">plugin：插件</h2><p>plugin找到webpack的钩子事件，介入控制编译</p><p>Tapable暴露的三个给插件的方法</p><ul><li>tap: 可以注册同步钩子和异步钩子</li><li>tapAsync 回调方式注册</li><li>tapPromise: Promise方式</li></ul><p>Plugin 构建对象</p><p>1.Compiler  保存完整的webpack环境配置</p><p>2.Compilation 一次资源的构建 资源处理 对构建依赖图中所有模块进行编译</p><p><img src="https://secure2.wostatic.cn/static/h6nhe4sbHRRSpVuZPD8xep/image.png?auth_key=1700037699-sDvdM4jTGfxTqto6uqXnWc-0-451a9aa841a3d84b3b32a1b4ee3848fd" alt=""></p><h4 id="生命周期执行顺序">生命周期执行顺序</h4><ul><li>webpack加载webpack.config.js所有配置，此时就会new一个实例插件， 就会执行constructor</li><li>webpack创建compiler对象</li><li>遍历所有plugins的apply方法，调用</li><li>执行剩余编译 触发各个hooks</li></ul><p>钩子：make  afterCompiler emit</p><h4 id="注册hooks">注册hooks</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPlugins</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>)<br>  &#125;<br>  <br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>)&#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;testPlugin&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">compilation</span>)=&gt;</span>&#123;&#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="loader和plugin的区别">loader和plugin的区别</h2><p>loader：文件加载器，加载资源文件，进行编译 压缩</p><p>plugin： 插件，解决loader无法解决的事情</p><p>不同：</p><p>loader：在打包文件前处理</p><p>plugin：贯穿了webpack的编译周期</p><h4 id="编写loader的本质：">编写loader的本质：</h4><p>loader本质是一个函数 他不能用箭头函数写 因为他的this作为上下文被webpack填充了</p><p>函数有三个参数 content map meta</p><p>是作为源文件内容的</p><p>他有四个类型  同步 异步  raw pitch</p><p>异步的话 ： const callback = this.async()  需要return</p><h4 id="编写plugins的本质">编写plugins的本质</h4><p>plugin在创建过程中会产生两个核心的对象</p><p>1.compiler  包含了所有配置信息</p><p>2.compilation  作为回调的参数 资源的构建</p><p>插件 是一个函数 或者是 包含apply方法的对象</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于性能优化的七七三三</title>
    <link href="/2023/11/05/%E5%85%B3%E4%BA%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%83%E4%B8%83%E4%B8%89%E4%B8%89/"/>
    <url>/2023/11/05/%E5%85%B3%E4%BA%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%83%E4%B8%83%E4%B8%89%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="SSR服务端渲染">SSR服务端渲染</h2><p>SSR与CSR渲染页面，都是服务端传回html。不同的是，csr的时候服务端先传回js，在传回data。而ssr是先传回数据，在传回js。因此提升了首屏渲染速度。</p><h3 id="ssr流程">ssr流程</h3><p>ssr允许用户在浏览器加载和执行js之前看到渲染内容。</p><ol><li>在服务端，获取需要的数据</li><li>在服务端，生成html并返回</li><li>在客户端，加载应用所需要的js</li><li>在客户端，将js注入到html中，也就是&lt;%note primary @注水%&gt;<br>以上所有的步骤，是按顺序完成的，也就是上一步完成之后，才可以开始。所以有可能会造成堵塞。</li></ol><h4 id="ssr优点">ssr优点</h4><ol><li>利于seo</li><li>更快的首屏加载速度，不需要等待js</li><li>安全性</li><li>代码复用性</li></ol><h4 id="缺点">缺点</h4><ol><li>服务端压力大</li><li>开发难度提升</li><li>不利于实现动态交互，一些依赖客户端的插件或者第三方库无法在服务端运行。</li><li>方案需要开发成本和维护成本</li><li>会影响最终的可交互时间</li></ol><p><img src="https://s2.loli.net/2023/11/16/sWE9rRYnUfcLBaV.png" alt="react18的作用"></p><h2 id="页面白屏">页面白屏</h2><h3 id="出现的原因">出现的原因</h3><ol><li>资源加载如css，图片等失败</li><li>第三方插件加载失败</li><li>资源加载阻塞</li></ol><h3 id="解决方案">解决方案</h3><ol><li>在dom根元素下插入onerror方法<br>dom一般挂载在根元素下，发生异常后，通过监听onerror事件，查看根节点下是否有元素，若无则证明白屏。<br>&lt;% note success&gt;缺点是，有骨架屏等情况下无法监听&lt;% endnote %&gt;</li><li>mutation observer监听dom变化<br>通过api监听dom变化，但是无法兼顾</li></ol><ul><li>骨架屏或者页面长期无变化的情况下，无法分辨</li><li>白屏不一定是组件被卸载也可能是压根没渲染。</li></ul><ol start="3"><li>页面截图监测</li><li>采样对比<br>对页面关键点，采样对比</li></ol><h2 id="性能优化的指标">性能优化的指标</h2><p>根据web-vitals提供的性能指标一共大约有五项。</p><ol><li>FCP： 首次内容绘制时间 &lt;=1s</li><li>LCP： 最大内容渲染时间 &lt;=2s</li><li>TTFB: 页面发出请求，到接收到第一个字节花费的时间 &lt;=100ms</li><li>FID： 首次输入延迟，就是用户触发行为后，到浏览器的响应时间 &lt;=100ms</li><li>CLS: 累积布局偏移 &lt;=0.1</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react和vue的区别</title>
    <link href="/2023/11/02/react-%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/11/02/react-%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>Vue和React作为两个大框架，总是被拿来问区别和选型。零零散散的，想到哪是哪。所以想着做一个收集的总和。</p><h2 id="概述">概述</h2><h4 id="Vue">Vue</h4><p>Vue是一个用于构建用户界面的渐进式框架，自底向上的增量开发。它的定位是<strong>降低前端开发的门槛</strong></p><blockquote><p>渐进式框架：允许开发者逐渐引入它的核心库和附加的生态系统库。也就是说他可以逐渐引入所需要的功能，不必要的功能可以先不引入。</p></blockquote><h4 id="React">React</h4><p>React主张<strong>函数式编程的理念</strong>，善于处理组件化的页面。</p><h3 id="共同点">共同点</h3><ul><li>数据驱动视图</li><li>单一数据流，响应式开发</li><li>使用虚拟dom+diff算法</li><li>组件化思想</li></ul><h2 id="核心思想">核心思想</h2><p>从核心思想上捋一下，代码层面的问题。</p><h3 id="写法差异">写法差异</h3><p>Vue：template模版，（Vue2以上引入vdom概念，也可以使用jsx）,拥抱经典的html+css+js，提供一些指令，数据劫持的方式进行监听，对组件的渲染更加精准<br>React：JSX all in js 更加灵活。setState的引入使得更新时自顶向下的，父组件props改变，子组件也会重新渲染，需要优化</p><h3 id="api差异">api差异</h3><p>Vue：template+options api 需要理解一些自定义指令，slot，filter等。<br>React：api较少，知道setState就可以开发。</p><h3 id="社区生态差异">社区生态差异</h3><p>Vue：有很多官方主导开发的解决方案，比如vuex，vue-router等等<br>React：只关注底层，上层应用解决方案基本不插手。大部分都丢给社区解决，导致社区比较繁荣。</p><h3 id="响应式原理">响应式原理</h3><p>Vue：数据监听，数据劫持<br>React：setState,状态机，数据不可变</p><h3 id="diff算法">diff算法</h3><pre><code class="hljs">- 对比节点，节点元素相同，classname不同，  - vue：认为是不同的类型，删除重建。  - react：认为是同类型，只修改节点属性- 对比列表  - vue：两段到中间  - react：从左到右</code></pre><h3 id="vuex和redux">vuex和redux</h3><pre><code class="hljs">vuex：数据可变，原理通过getter/setter实现redux：数据不可变，通过diff比较差异</code></pre><h2 id="技术选型">技术选型</h2><h3 id="浅浅的想象">浅浅的想象</h3><p>原则上来说，从开发角度，学习成本，上手难易，以及性能去对比，差距不是很大。而且学习成本，上手难度来比较，很没有说服力。<br>通俗的约定是：react用大项目，vue用小项目。然而大小项目的区分没有标准。</p><h3 id="深度的比较">深度的比较</h3><h4 id="市场占比">市场占比</h4><p>从npm下载量来说，react较为领先。了解到react许可的问题，保留vue的技术栈总是没错滴。</p><h4 id="生态和ui组件库">生态和ui组件库</h4><p>生态上react比vue好一点，但是核心还是用代码这方面，并不能作为优势去考量。<br>组件库上大差不差，都很丰富。<br>都可以访问ref，操作dom</p><h3 id="小程序框架开发">小程序框架开发</h3><p>常见的框架</p><ol><li>芋头 react</li><li>wepy vue</li><li>uni-app vue<br>这些都是基于框架二次开发的。<br>vue的一些周边库，高度依赖于vue，和vue强绑定。而redux他可以再react用，也可以再vue上用。类似的问题很多，总结下就是，react的东西可以再vue上用，但是反过来vue不可以。<br>比如wepy 他不支持vuex 支持redux</li></ol><h3 id="app生态">app生态</h3><p>rn 和 weex</p><h3 id="代码层面-jsx和template">代码层面 jsx和template</h3><h4 id="可测试性，重构">可测试性，重构</h4><p>vue需要另起一个页面，react可以直接借助jsx语法实现一个函数方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params">props: &#123; hello: string &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.hello&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一部分丢失">一部分丢失</h4><p>在vue的页面，封装一些函数，引入的时候需要在methods中重新申明一次。</p><h4 id="this指针">this指针</h4><p>在react里，函数组件这张是没有this指针的，在多人协作或者承接的时候，显得尤为简洁。</p><h4 id="参考文档">参考文档</h4><p><a href="https://developer.aliyun.com/article/1207640">vue和react深度比较</a><br><a href="https://cloud.tencent.com/developer/article/2271788">vue和react的技术选型</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react 常见问题</title>
    <link href="/2023/11/02/react-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/02/react-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="react16做了哪些更新">react16做了哪些更新</h2><p>react16之前，虚拟dom的diff算法 理解是一个递归的过程，树如果复杂的话，会堵塞后面的渲染，交互响应迟钝，出现卡顿。因此引入了fiber架构。他引入了任务优先级制度和requestIdleCallback，循环调度。将之前一根筋的渲染方式拆成了两个部分。</p><ol><li>render阶段 也就是reconciliation 插入高优先级任务，被拆分成一个个小的fiber，在浏览器的<strong>空闲时间</strong>做diff</li><li>commit阶段 不可打断， 直接执行最高优先级任务</li></ol><p><strong>由于render阶段可以打断 + 任务优先级问题</strong>，使得很多生命周期被多次执行。因此react17之后componentWillMount,componentWillUpdate, componentWillReceivieProps被取缔。</p><p><strong>引入了workProgressHook和currentHook</strong>，构建了两个workInProgress和current树，两个链表互相引用，如果workInProgress树生成失败，则更新失败，但是页面不会崩溃。</p><h2 id="为什么-react要用hooks链表呢">为什么 react要用hooks链表呢</h2><p>如果有多个同个hook调用，还需要有调用的先后顺序，使用next串联所有的hook，同时有一个workProcessHook指针记录当前调用的是哪个hook，方便下次更新时获取上一次更新的对象。在下一次更新时，再次执行hook，就会去找到当前运行节点的链表。</p><p>链表的好处在于，即便暂停了，也可以用next记录下一次执行的节点，一旦浏览器有了空余时间，可以直接从这个next开始恢复。</p><h2 id="为什么只能在函数最外层调用HOOK，不能在循环，条件里调用">为什么只能在函数最外层调用HOOK，不能在循环，条件里调用</h2><p>因为hook每次调用都会生成一个hook链表挂在fiber.memoizedstate上，按顺序挂的。挂载和更新必须保证是队列是一致的，不然会引起异常报错。</p><h2 id="react-hooks的引入解决了什么">react hooks的引入解决了什么</h2><p>react的设计思想： 数据驱动视图。<br><code>view = fn(state) </code></p><h3 id="hooks出现前的逻辑复用">hooks出现前的逻辑复用</h3><p>主要是通过hoc和render props 解决，面对复杂业务，会引发<strong>嵌套地狱</strong>和<strong>引发diff算法性能问题</strong></p><blockquote><p>在react16出现之前，函数组件是一个无状态的组件，为什么呢？ 因为16以前只有在类组件更新时会生成一个实例。16之后引入fiber，每个节点都有对应的案例。</p></blockquote><h3 id="hooks的本质">hooks的本质</h3><p><strong>闭包</strong> + <strong>两个链表</strong></p><blockquote><p>闭包</p><blockquote><p>有权访问另一个函数里的变量和方法的函数。通过闭包可以突破作用域的特点，将函数内部的方法和变量传到外部。</p></blockquote></blockquote><p>两个链表分别是：</p><ol><li>hooks链表</li><li>update链表 是一个环形链表，这样呢  尾部遍历完可以直接找到第一个头，在尾部插入也会快速定位，不需要遍历。</li></ol><h2 id="setState为什么默认是异步，什么时候是同步？">setState为什么默认是异步，什么时候是同步？</h2><p><strong>这里的异步同步不同于promise的那种，指的是setState之后数据会不会立马变化。</strong><br>在setState方法中，有一个字段isBatchingUpdates可以判断是否直接更新还是批量。<br>isBatchingUpdates为true，代表批量更新，也就是异步。<strong>默认为false</strong><br>react有一个函数batchedUpdates会把这个值isBatchingUpdates变为true，也就是变为异步。因此只要绕过react事件机制的方法都是同步的。因为react在调用事件处理机制时都会调用这个batchedUpdates这个方法。<br><strong>本身也可以通过setstate或者usestate第二个参数返回一个callback，也可以立马获取。</strong><br>react17中暴露了这个方法<code>batchedUpdates</code>，包一下也可以批量更新。<br>react18中直接处理了 全都是批量更新。<br>具体来说</p><ul><li>react引发的事件处理 （onclick等） 异步</li><li>绕过react通过绑定addeventlistner，或者settimeout等等 同步</li></ul><h2 id="useContext为什么不会被挂到hook链表上">useContext为什么不会被挂到hook链表上</h2><p>因为在初始化和更新时会有两套不同的函数执行，mount 和 update，但是useContext只有一套代码，都是readContext.所以不需要挂载链表上。<br>原理类似于观察者模式。Provider上的值发生变化，通知给context和consumer</p><h2 id="useContext-和-redux-的区别">useContext 和 redux 的区别</h2><ul><li>context<ul><li>适合做全局管理</li><li>避免props传递的繁琐</li><li>如果组件依赖了context， 只要局部更新，组件都会一起更新，加上memo也没用，因为memo依赖的是props</li><li>一般情况下可以替代redux</li></ul></li><li>redux<ul><li>去中心化思想，适合一些编辑器的场景，可以多状态</li><li>多个组件，或者多个页面共享状态</li><li>维护起来麻烦，新增的属性需要一一去添加</li></ul></li></ul><h2 id="useLayoutEffect-和-useEffect区别">useLayoutEffect 和 useEffect区别</h2><p>react的一次更新分为2个阶段：</p><ul><li>render阶段： 构建一个fiber树，也就是workInProgress树；构建过程中，从root开始深度优先遍历再回溯到root<ul><li>beginWorker ：组件状态的计算，diff，render函数</li><li>completeWorker：收集effect依赖链表，收集被跳过的update对象</li></ul></li><li>commit阶段 ： 异步执行useEffect，同步执行useLayoutEffect。<br><strong>useEffect要在页面渲染完之后才执行，不会堵塞页面，后者则是在dom更新完成，还没有开始渲染前执行。</strong><br>整体流程上都是先在render阶段，生成effect，并将它们拼接成链表，存到fiber.updateQueue上，最终带到commit阶段被处理。他们彼此的区别只是最终的执行时机不同，一个异步一个同步，这使得useEffect不会阻塞渲染，而useLayoutEffect会阻塞渲染。</li></ul><h2 id="useRef-和-useState区别">useRef 和 useState区别</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">useRef</th><th style="text-align:center">useState</th></tr></thead><tbody><tr><td style="text-align:center">use</td><td style="text-align:center">用于对dom的引用，保存值，不会被重新渲染</td><td style="text-align:center">保存和更新组件的状态，值会被重新渲染</td></tr><tr><td style="text-align:center">更新</td><td style="text-align:center">同步更新</td><td style="text-align:center">异步更新</td></tr><tr><td style="text-align:center">返回</td><td style="text-align:center">一个全局可以访问和修改的ref对象</td><td style="text-align:center">当前状态和一个状态更新函数</td></tr></tbody></table><h3 id="useRef">useRef</h3><ol><li>在整个生命周期中保持不变</li><li>更改ref.current 不会引起组件的渲染， 不会触发re-render</li><li>useref 只在组件更新的时候渲染一次</li><li>usestate更新，可以被useeffect监听到， useref不可以</li><li>useref更新的是副作用</li></ol><p>参考：<a href="https://blog.csdn.net/sinat_28071063/article/details/129302701">useRef的值可以被useEffect监听吗</a></p><h3 id="ref-callback"><a href="https://juejin.cn/post/7187429820928622629">ref callback</a></h3><p>ref 可以接受一个ref对象，也可以接受一个callback函数</p><blockquote><p>这个callback函数只有一个 dom元素 创建dom元素 立即执行，销毁也会执行一次 传参dom为null<br>仅在挂载和卸载时调用<br>可能引起一些不必要的调用，可以用useCallback包装</p></blockquote><p>用途场景：</p><ul><li>操作 DOM，比如在组件挂载的时候滚动或聚焦</li><li>在 React 获取 DOM 属性，比如宽度或滚动位置</li><li>在 React 控制的 DOM 元素上使用 Portal</li><li>将 DOM 元素提供给多个消费者</li></ul><h2 id="react-hook-的一些闭包问题-和陷阱">react hook 的一些闭包问题 和陷阱</h2><p><a href="https://juejin.cn/post/6844903982037467143">https://juejin.cn/post/6844903982037467143</a><br><a href="https://juejin.cn/post/6844904193044512782">https://juejin.cn/post/6844904193044512782</a></p><h2 id="父组件和子组件的useEffect哪个先更新">父组件和子组件的useEffect哪个先更新</h2><p>dom render 和 主线程 先执行<br>useEffect 在之后执行<br><strong>dom render</strong> 永远在useEffect之前执行</p><ul><li>父子组件 ：<ul><li>dom render 和 主线程： 父 -&gt; 子</li><li>useEffect 在之后执行 ： 子 -&gt; 父</li></ul></li><li>兄弟组件：<ul><li>按前后顺序，递归</li><li>如果组件含有子组件，则先执行完子组件 ，在走兄弟<br><a href="https://juejin.cn/post/7169526604199100447">react中函数组件 - 父子组件的执行顺序</a></li></ul></li></ul><ol><li>渲染顺序：React 的渲染过程是从父组件开始的，这是因为父组件通常包含子组件的引用。因此，父组件需要首先渲染以确定子组件应该如何渲染。</li><li>副作用和生命周期方法的执行：在所有组件都渲染完成后，React 会开始执行副作用和生命周期方法。这个过程是从最底层的子组件开始的，然后逐级向上。这样做的原因是，子组件通常是父组件逻辑的一部分，父组件的副作用可能依赖于子组件的状态或 DOM 元素。</li></ol><blockquote><p>父子组件的return（destroy）事件呢<br><a href="https://codesandbox.io/s/uselayouteffect-zhixingshunxu-h5gg2?file=/src/App.js">demo</a></p></blockquote><ol><li>在删除dom时，从父-&gt;子 删除  destroy</li><li>在更新dom时，或者更新和删除都有时， 子-&gt;父 destroy<br><strong>无论什么情况</strong>都是先执行所有的destroy 在执行create方法</li></ol><h2 id="useEffect-return的意义">useEffect return的意义</h2><p>每次重新渲染，都会让原组件（包括子组件）销毁，在重新诞生。</p><ul><li>首次渲染，不会执行return</li><li>再次渲染，会先执行return ，在执行外面的</li><li>return的回调，可以用来清除一些定时器</li></ul><h2 id="react类组件的生命周期-现在有哪些">react类组件的生命周期 现在有哪些</h2><p>前文提到的引入了fiber+优先级制度，导致原先一些生命周期会混乱</p><ul><li>componentWillMounte/Update/RecieveProps 在16,17被取消</li><li>引入getDerivedStateFromProps(nextProps, nextState) 替代了上三者，render前调用，挂载更新后也会调用，<strong>如果state的值在任何时候都依赖于props时才使用此方法</strong>。<ul><li>让组件在props更新后更新state；</li><li>返回一个对象，为null不更新。</li></ul></li><li>shouldComponentUpdate： 如果返回false，则不执行componentDidUpdate，也不会执行render；返回值默认是true。</li><li>render</li><li>getSnapshotBeforeUpdate在render之后，componentDidUpdate之前，</li><li>componentDidUpdate<br>更新阶段的生命周期：</li></ul><blockquote><p>static getDerivedStateFromProps()<br>shouldComponentUpdate()<br>render()<br>getSnapshotBeforeUpdate()<br>componentDidUpdate()</p></blockquote><h2 id="React的错误边界">React的错误边界</h2><p>过去，组件内的代码异常会导致整个react内部状态破坏，一个组件在渲染期间发生错误，会卸载整个组件。因此引入了错误边界。</p><blockquote><p>只能在类组件中使用，不能在hook中使用。因为需要用this.setState的回调传递callback，useState无法传入回调。<br>以下四种场景无法捕获错误边界</p><blockquote><ul><li>事件处理函数，需要用原生的trycatch</li><li>setTimeout等异步代码</li><li>服务端渲染</li><li>他自己本身的错误</li></ul></blockquote></blockquote><div class="note note-primary">            <p>错误边界是一种组件， 他可以记录下渲染的错误，然后展示降级的ui。</p>          </div><p>实现错误边界的方法 依据两个生命周期</p><div class="note note-primary">            <p><strong>getDerivedStateFromError</strong>和<strong>componentDidCatch</strong></p>          </div><ul><li>getDerivedStateFromError: 静态方法，给个机会去渲染降级ui</li><li>componetDidCatch： 组件实例方法，当错误发生后，记录错误<br>当一个类组件定义了以上二者其一的时候，就会被定性为错误边界。<br><strong>一般来说，会包在最顶层的路由组件</strong>、具体的粒度有自己决定<br>需要注意的是，从react16开始，没有被错误边界捕获的错误会导致整个react组件树被卸载。<br>因为 有的时候，留下一个错误的ui 比 完全移除他 更糟糕。</li></ul><h4 id="react的fiber-vue为什么不需要fiber">react的fiber vue为什么不需要fiber</h4><p>react的fiber机制：是由于react内状态不可修改，所以需要自顶向下的去渲染树。本身会在内部生成一颗巨大的虚拟dom树，给第二步的diff带来了很大的性能消耗。而js占据主线程，渲染线程就无法工作。所以出现了react的fiber。<br>fiber 是一种纤程。他通过requestIdleCallback 去控制组件渲染。<br>vue的渲染机制：vue2使用的Object.defineProperty或者vue3中的proxy对数据做一个劫持。vue能准确的知道视图模版中哪一块需要更新。他本身可以实现精准更新，精确到当前组件的最小粒度。一方面：是给每个组件配置了<span class="label label-primary">监听器</span>，管理视图的依赖收集和数据更新。一方面：他的<strong>模版语法，可以实现静态编译</strong>，react的jsx语法是做不到的。这两者对性能也是有消耗的。但是他就不需要fiber去控制组件渲染，让出浏览器线程这类操作了。</p><h2 id="diff算法">diff算法</h2><p>Diff算法通过key和tag来对节点进行取舍，可直接将复杂的比对拦截掉，然后降级成节点的移动和增删这样比较简单的操作。对oldFiber和新的ReactElement节点的比对，将会生成新的fiber节点，同时标记上effectTag，这些fiber会被连到workInProgress树中，作为新的WIP节点。树的结构因此被一点点地确定，而新的workInProgress节点也基本定型。这意味着，在diff过后，workInProgress节点的beginWork节点就完成了。接下来会进入completeWork阶段</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hooks 链表</title>
    <link href="/2023/11/02/hooks-%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/11/02/hooks-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>Hooks 单向链表</h1><p>初始挂载和更新的 hooks，是不同的。<br>初始化的 useEffect，和 更新渲染后的 useEffect，是在两个不同的阶段调用。本质上是两个函数。<br><strong>本质上来源于函数组件要维护一个 hooks 的链表，初始化创建链表，更新的时候更新链表</strong></p><p>分属于两个过程的 hook 函数会在各自的过程中被赋值到<em>ReactCurrentDispatcher</em>的 current 属性上。所以在调用函数组件之前，当务之急是根据当前所处的阶段来决定 ReactCurrentDispatcher 的 current，这样才可以在正确的阶段调用到正确的 hook 函数。<em>HooksDispatcherOnMount</em> ，<em>HooksDispatcherOnUpdate</em> 这俩内部是不一样的，不同阶段对 hook 的处理不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnMount</span>: <span class="hljs-title class_">Dispatcher</span> = &#123;<br>  <span class="hljs-attr">useCallback</span>: mountCallback,<br>  <span class="hljs-attr">useContext</span>: readContext,<br>  <span class="hljs-attr">useEffect</span>: mountEffect,<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnUpdate</span>: <span class="hljs-title class_">Dispatcher</span> = &#123;<br>  <span class="hljs-attr">useCallback</span>: updateCallback,<br>  <span class="hljs-attr">useContext</span>: readContext,<br>  <span class="hljs-attr">useEffect</span>: updateEffect,<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="认识-hooks-链表">认识 hooks 链表</h2><p>hook 的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hook = &#123;<br>  <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,<br><br>  <span class="hljs-attr">next</span>: &#123;<br>    <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>无论是挂载还是更新，只要调用一次hooks函数，就会生成一个hook对象。依次排列，形成链表 存在<font style="color:#d63384">fiber.memoizedState</font>.有一个指针workInProgressHook会记录当前生成的hook对象，可以反应出调用到哪个hook。</p><h3 id="组件挂载">组件挂载</h3><p>初次挂载时，组件上没有任何hooks的信息，所以，这个过程主要是在fiber上创建hooks链表。挂载调用的是mountWorkInProgressHook，它会创建hook并将他们连接成链表，同时更新workInProgressHook，最终返回新创建的hook，也就是hooks链表。</p><h3 id="组件更新">组件更新</h3><p>由于存在current树，也会存在currentHook。自然就是有两条hook链表，分别存在workInProgress和current节点的memoizedSate。</p><p><strong>useContext不会被挂到hook链表上</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react 核心概念</title>
    <link href="/2023/11/02/react-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/02/react-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1>React的核心概念</h1><hr><p>基于两点介绍</p><ol><li>Fiber架构和schedule调度</li><li>优先级机制</li></ol><h2 id="Fiber是什么">Fiber是什么</h2><p>Fiber是什么？它是React的最小工作单元，在React的世界中，一切都可以是组件。在普通的HTML页面上，人为地将多个DOM元素整合在一起可以组成一个组件，HTML标签可以是组件（HostComponent），普通的文本节点也可以是组件（HostText）。<br><strong>每一个组件都可以对应一个fiber节点</strong>，互相嵌套，组成fiber树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fiber = &#123;<br>  alternate,<br>  child,<br>  <span class="hljs-attr">elementType</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  <span class="hljs-attr">memoizedProps</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 在函数组件中，memoizedState用于保存hook链表</span><br>  <span class="hljs-attr">pendingProps</span>: &#123;&#125;,<br>  <span class="hljs-keyword">return</span>,<br>  sibling,<br>  stateNode,<br>  tag, <span class="hljs-comment">// fiber的节点类型，初次渲染时，函数组件对应的tag为2，后续更新过程中对应的tag为0</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-attr">updateQueue</span>: <span class="hljs-literal">null</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fiber架构下的react是如何更新的">Fiber架构下的react是如何更新的</h3><p>react的一次更新分为两个阶段</p><ul><li>render阶段</li><li>commit阶段</li></ul><h5 id="render阶段">render阶段</h5><blockquote><p>render阶段是 scheduler调度+ reconcile 就是把虚拟dom变成fiber<br>render阶段是在内部构建一颗新的fiber树，一般成为workInProgress树，构建过程依据现有的fiber树（current树），从root开始深度遍历再回溯到root。创建effect链表</p></blockquote><p>每个fiber会经历两个阶段：</p><ul><li>beginWorker: 组件状态的计算，diff的操作，render函数的执行</li><li>completeWorker: 被跳过的优先级update收集， effect链表的收集</li></ul><p><strong>构建work树过程会有一个指针记录构建到哪个fiber节点，以便更新任务可恢复</strong></p><h5 id="beginWorker">beginWorker</h5><p>它的职能主要是<strong>节点更新的入口，不会直接更新</strong>，就是拦截无需更新的节点。</p><blockquote><p>处理当前遍历的fiber，返回它的子fiber，构建workInProgress树。<br>核心更新的过程在于 <strong>计算状态</strong>  和 <strong>diff算法</strong></p></blockquote><h5 id="如何区分初始化和更新">如何区分初始化和更新</h5><p><strong>判断是否存在current</strong><br>初始化不会有current，更新时已经存在current树<br>根据节点是否是首次渲染 生成fiber 或者diff fiber</p><h5 id="commit阶段">commit阶段</h5><blockquote><p>把fiber变成dom</p></blockquote><ul><li>不可中断</li><li>根据收集到的变化节点更新dom，异步执行useeffect 同步执行uselayouteffect</li></ul><blockquote><p>这两个任务都是独立的React任务，都会被schedule调度。<br>render阶段的优先级是根据本次的更新的优先级决定的，高优先级可以打断低优先级<br>commit阶段的优先级不可打断，按最高优先级来执行</p></blockquote><h4 id="schedule调度">schedule调度</h4><p>根据优先级进行调度，保证最高优先级执行<br>根据时间片对任务进行中止和恢复。</p><h4 id="优先级机制">优先级机制</h4><p><strong>如何将优先级机制融入 react 运行时</strong></p><p><strong>1. 获取本次更新优先级</strong></p><p>调用 <code>requestUpdateLane</code> 函数获取本次更新任务的优先级</p><p>优先级选取判断顺序如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">SyncLane</span>  &gt;&gt;  <span class="hljs-title class_">TransitionLane</span>  &gt;&gt;  <span class="hljs-title class_">UpdateLane</span>  &gt;&gt;  <span class="hljs-title class_">EventLane</span><br></code></pre></td></tr></table></figure><p><strong>2. 创建 Update 对象</strong></p><p>setState 生成 Update 对象，每个对象里有个 lanes 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createUpdate</span>(<span class="hljs-params">eventTime, lane</span>) &#123;<br>  <span class="hljs-keyword">var</span> update = &#123;<br>    <span class="hljs-attr">eventTime</span>: eventTime,<br>    <span class="hljs-attr">lane</span>: lane,<br>    <span class="hljs-attr">tag</span>: <span class="hljs-title class_">UpdateState</span>,<br>    <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> update;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 关联优先级</strong></p><ul><li><p>将优先级合并到当前 fiber 节点的 lanes 属性中</p></li><li><p>将优先级合并到父级节点的 childLanes 中 (告诉父节点他的子节点有多少条赛道要跑)</p></li><li><p>将调度任务优先级合并到当前 react 应用根节点上</p></li><li><p>计算当前任务优先级赛道占用的开始时间</p></li></ul><p>commit 阶段结束之后会释放占用的优先级</p><p><strong>4. 发起调度</strong></p><ul><li><p>高优先级任务打断低优先级任务</p><p>每一次调度都会对正在进行任务和当前任务最高优先级做比较，如果不相等，就代表有高优先级任务进来，需要打断当前正在的任务。</p></li><li><p>低优先级任务重启</p><p>协调 (reconcile) 的下一个阶段是渲染 (renderer)，也就是我们说的 commit 阶段，在此阶段末尾，会调用 ensureRootIsScheduled 发起一次新的调度，执行尚未完成的低优先级任务</p></li><li><p>饥饿任务问题</p><p>高优先级任务执行完毕则重启低优先级任务，如果持续有高优先级任务插入，如何处理？</p><p>每次调度的开始，都会先检查下有没有过期任务，如果有的话，下一次就会以同步优先级进行 render 任务(reconcile)，同步优先级就是最高的优先级，不会被打断</p></li></ul><p>交互就会生成更新，不同的更新，优先级不一样。<br>react中人为的进行了划分，最终目的是调度轻重缓急，因此产生了一套事件调度的优先级机制。</p><ul><li>事件优先级： 按照用户的交互产生的</li><li>更新优先级： 事件导致的react产生的update对象的优先级（update.lane)</li><li>任务优先级： 产生update对象后，react去执行的优先级</li><li>调度优先级： scheduler根据react的任务生的调度任务的优先级</li></ul><hr><h2 id="事件优先级">事件优先级</h2><ol><li>离散事件 click，keydown等不连续的 优先级0</li><li>用户阻塞事件 scroll drag mouseover 连续，阻塞渲染 优先级1</li><li>连续事件 canplay error audio标签的canplay等等，优先2 最高</li></ol><h3 id="派发事件优先级">派发事件优先级</h3><p>事件优先级在注册阶段确定，在root上注册时，会根据不同事件发不同的监听，最后绑定到root<br>然后借助scheduler中的runWithPriorty函数实现执行事件处理函数。</p><h2 id="更新优先级">更新优先级</h2><p>以setState为例，事件的执行会导致setState执行，而setState本质上是调用enqueueSetState，生成一个update对象，这时候会计算它的更新优先级，即update.lane</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> classComponentUpdater = &#123;<br>  <span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst, payload, callback</span>) &#123;<br>    ...<br><br>    <span class="hljs-comment">// 依据事件优先级创建update的优先级</span><br>    <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber, suspenseConfig);<br><br>    <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane, suspenseConfig);<br>    update.<span class="hljs-property">payload</span> = payload;<br>    <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);<br><br>    <span class="hljs-comment">// 开始调度</span><br>    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);<br>    ...<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>requestUpdateLane</strong>:找出scheduler中记录的优先级，计算更新：lane.</p><h2 id="任务优先级">任务优先级</h2><p>假设产生一前一后两个update，它们持有各自的更新优先级，也会被各自的更新任务执行。经过优先级计算，如果后者的任务优先级高于前者的任务优先级，那么会让Scheduler取消前者的任务调度；如果后者的任务优先级等于前者的任务优先级，后者不会导致前者被取消，而是会复用前者的更新任务，将两个同等优先级的更新收敛到一次任务中；如果后者的任务优先级低于前者的任务优先级，同样不会导致前者的任务被取消，而是在前者更新完成后，再次用Scheduler对后者发起一次任务调度。</p><p><strong>保证高优先级任务及时响应，收敛同等优先级的任务调度。</strong></p><blockquote><p>如果已经存在一个更新任务， 获得新任务的更新优先级之后，会进行比较，判断是否需要重新发起调度，如果需要，则计算调度优先级</p></blockquote><h2 id="调度优先级">调度优先级</h2><p>调度优先级由任务优先级计算得出，在ensureRootIsScheduled更新真正让Scheduler发起调度的时候，会去计算调度优先级。</p><p>在Scheduler中，分别用过期任务队列和未过期任务的队列去管理它内部的task，过期任务的队列中的task根据过期时间去排序，最早过期的排在前面，便于被最先处理。而过期时间是由调度优先级计算的出的，不同的调度优先级对应的过期时间不同。</p><h4 id="小总结">小总结</h4><p>这四种优先级 是<strong>递进</strong>的关系<br>事件优先级由事件本身决定，更新优先级由事件计算得出，然后放到root.pendingLanes，任务优先级来自root.pendingLanes中最紧急的那些lanes对应的优先级，调度优先级根据任务优先级获取。几种优先级环环相扣，保证了高优任务的优先执行。</p><h4 id="参考">参考</h4><ul><li><a href="https://segmentfault.com/a/1190000038947307">react优先级机制</a></li><li><a href="https://segmentfault.com/a/1190000039131960">Concurrent模式下React的更新行为- 优先级模型</a></li><li><a href="https://segmentfault.com/a/1190000039101758">react的调度机制原理</a></li></ul><hr><h4 id="双缓冲机制">双缓冲机制</h4><p>开始更新后，会有两棵树，一颗是workInProgress树，一棵是现有的current树，是当前页面显示的树。在更新未完成的时候，所有更新会在workInProgress树上，页面始终展示current，更新结束之后，两者替换。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react state计算更新 原理</title>
    <link href="/2023/11/02/react-state%E8%AE%A1%E7%AE%97%E6%9B%B4%E6%96%B0-%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/02/react-state%E8%AE%A1%E7%AE%97%E6%9B%B4%E6%96%B0-%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>react中的计算状态</h1><h2 id="概述">概述</h2><p>一旦用户的交互产生了更新，就会生成一个update对象去承接新的状态。多次更新（多次调用setState）会产生多个update对象，链接成一个环形链表：<strong>updateQueue</strong>，挂载在fiber节点上，然后在该fiber上的beginWorker阶段循环updateQueue，依次处理。在React中，类组件和根组件用一类update对象，函数组件用另一类。<br><strong>useEffect, useImperativeHandle, useLayoutEffect,只有这三个hook会产生副作用，updateQueue同时也要收集这些副作用。</strong></p><h4 id="update对象结构">update对象结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> update =&#123;<br>    eventTime, <span class="hljs-comment">// update的产生时间，如果因为低优先级则会报超时，react会调用他一次</span><br>    lane,<span class="hljs-comment">// update的优先级</span><br>    suspenseConfig,<span class="hljs-comment">// 任务挂起相关</span><br>    tag,<span class="hljs-comment">// 更新的类型 updatestate, replacestate, forceUpdate, captureUpdate</span><br>    payload,<span class="hljs-comment">// 更新携带的状态  分为类组件和根组件 根组件中是react.element</span><br>    callback,<span class="hljs-comment">// setstate的回调</span><br>    next,<span class="hljs-comment">// 指向下一个update的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="updateQueue的结构">updateQueue的结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> queue =&#123;<br>    baseState,<span class="hljs-comment">//前一次更新计算得出的state</span><br>    firstBaseUpdate,<span class="hljs-comment">//前一次更新时updateQueue第一个被跳过的update对象</span><br>    lastBaseUpdate,<span class="hljs-comment">//以first为起点到最后一个update的队列中最后一个</span><br>    <span class="hljs-attr">shared</span>:&#123;<br>        <span class="hljs-attr">pending</span>:<span class="hljs-literal">null</span><span class="hljs-comment">//存储这本次更新的update队列</span><br>    &#125;,<br>    <span class="hljs-attr">effects</span>:<span class="hljs-literal">null</span><span class="hljs-comment">//数组，保存update.callBack不为空的update</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么更新队列是环状</p><blockquote><p>因为方便定位到链表的第一个元素，链表最后一个指针指向第一个update，否则需要遍历。<br>环状链表，只需记住尾部，无需遍历所有操作</p></blockquote></blockquote><h4 id="firstBaseUpdate，-lastBaseUpdate的概念及作用">firstBaseUpdate， lastBaseUpdate的概念及作用</h4><blockquote><p>A1 -&gt; B1 -&gt; C2 -&gt; D1 -&gt; E2</p></blockquote><p>举例： 字母为状态， 数字为优先级（越小越高）<br>第一次渲染队列 以 A1-&gt;B1-&gt;D1 ，遇到C2跳过</p><p><strong>本次更新完成之后，firstBaseUpdate:C2 lastBaseUpdate:E2, baseState:AB</strong></p><blockquote><p>为什么baseState中只有AB,没有D呢</p><ol><li>因为baseState的定义是 被跳过的update之前那些update所计算出的状态。</li><li>这样目的是为了保障最终的updateQueue所有优先级的update处理完之后和预期结果一直。也就是说，虽然第一次计算结果为ABD，但是最终的结果一定是ABCDE</li></ol></blockquote><h3 id="更新的处理机制">更新的处理机制</h3><ul><li>准备阶段</li><li>处理阶段</li><li>完成阶段</li></ul><h4 id="准备阶段">准备阶段</h4><p>主要是整理updateQueue，可能有两条队列</p><ol><li>上次遗留的 从first-last</li><li>本次新增的<br>将这两条合并起来，但不需要合并成环型，方便从头到尾遍历。</li></ol><p><strong>另外，这次的操作都在workInProgress中，因此需要在current节点上操作一次，保持同步</strong></p><h4 id="处理阶段">处理阶段</h4><p>循环处理上一个整理好的队列</p><ol><li>本次更新依然取决于优先度（update.lane和 renderLanes 渲染优先度）</li><li>本次的结果基于baseState</li></ol><h5 id="优先级不足的情况">优先级不足的情况</h5><p>update被跳过</p><ul><li>将被跳过的整理到first和last中</li><li>记录baseState，只在第一次跳过时记录，因为低优先级任务重做时，会从第一个被跳过的开始执行</li><li>记录被跳过的update优先级，更新即将结束之后放进workInProgress.lanes,得以再次发起，重做低优先级。</li></ul><blockquote><p>第一次更新的baseState 是空字符串，更新队列如下，字母表示state，数字表示优先级。优先级是1 &gt; 2的<br>A1 - B1 - C2 - D1 - E2<br>第一次的渲染优先级（renderLanes）为 1，Updates是本次会被处理的队列:<br>Base state: ‘’<br>Updates: [A1, B1, D1]      &lt;- 第一个被跳过的update为C2，此时的baseUpdate队列为[C2, D1, E2]，<br>它之前所有被处理的update的结果是AB。此时记录下baseState = ‘AB’<br>注意！再次跳过低优先级的update(E2)时，则不会记录baseState<br>Result state: ‘ABD’--------------------------------------------------------------------------------------------------<br>第二次的渲染优先级（renderLanes）为 2，Updates是本次会被处理的队列:<br>Base state: ‘AB’           &lt;- 再次发起调度时，取出上次更新遗留的baseUpdate队列，基于baseState<br>计算结果。<br>Updates: [C2, D1, E2] Result state: ‘ABCDE’</p></blockquote><h5 id="优先级足够的情况">优先级足够的情况</h5><ul><li>如果baseUpdate不为空，放入baseUpdate队列</li><li>处理更新，计算新状态<br>主要是为了让最终全部更新完成的结果与预期的结果一致。</li></ul><h5 id="完成阶段">完成阶段</h5><p>完成赋值和优先级标记</p><ul><li>赋值baseState，first，last，updateQueue</li><li>如果任务完成，代表没有优先级被跳过，意外着本次的update都处理完了，lanes清空；如果不是，则重新将低优先级的update放入lanes</li><li>更新workInProgress节点上的memoizedState</li></ul><h2 id="总结">总结</h2><p>对更新的处理都是围绕优先级。processUpdateQueue函数的主要目的就是处理更新。<br><strong>优先级被跳过时，需要记住他的状态和此时的优先级之后的更新队列，还要将队列放到current节点中，做备份。</strong><br>目的是不乱序，完整处理。<br>参考文章：<a href="https://segmentfault.com/a/1190000039008910">扒一扒React计算状态的原理</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
